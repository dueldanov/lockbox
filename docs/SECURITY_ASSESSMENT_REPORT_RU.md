# Отчёт по безопасности LockBox

**Подготовлено для:** Product Owner и заинтересованных сторон
**Дата:** 3 декабря 2025
**Версия:** 2.0 (Исправленная)
**Классификация:** Конфиденциально

---

## Краткое резюме

Мы провели комплексный аудит безопасности кодовой базы LockBox. Система предназначена для защиты заблокированных криптоактивов посредством шифрования, доказательств с нулевым разглашением (ZKP) и программируемых условий разблокировки.

### Вердикт: НЕ ГОТОВО К ПРОДАКШЕНУ

Обнаружено **27 проблем** в криптографии, управлении ключами и архитектуре системы. **Девять из них — критические уязвимости**, приводящие к:

- Полной потере данных (ключи шифрования нулевые/теряются)
- Полному обходу контроля безопасности (подписи не проверяются)
- Нефункциональным базовым возможностям (сериализация сломана)

### Ключевой вывод

Система **вообще не функционирует** в текущем состоянии. Критические баги не позволяют выполнять базовые операции, даже не рассматривая атаки на безопасность.

---

## Критические находки

### 1. Мастер-ключ шифрования всегда равен нулю ⚠️ НОВОЕ

**Расположение:** `internal/crypto/hkdf.go:55-56`

Мастер-ключ никогда не копируется в структуру HKDF менеджера. Код создаёт пустой байтовый слайс, но никогда не заполняет его реальным ключом.

```go
// Текущий код:
masterKey: make([]byte, len(masterKey)),  // Создаёт нули
// Отсутствует: copy(h.masterKey, masterKey)
```

**Бизнес-влияние:** Всё шифрование использует предсказуемые нулевые ключи. Данные фактически не защищены. Любой атакующий, знающий алгоритм, может расшифровать все активы.

**Критичность:** КАТАСТРОФИЧЕСКАЯ

---

### 2. Ключи шифрования теряются при каждом перезапуске

**Расположение:** `internal/service/service.go:58-62`

Система генерирует новый мастер-ключ при каждом запуске. Этот ключ никогда не сохраняется.

**Бизнес-влияние:** Полная и необратимая потеря всех активов пользователей после любого перезапуска сервера, обновления или сбоя.

**Критичность:** КАТАСТРОФИЧЕСКАЯ

---

### 3. Десериализация шардов возвращает пустые данные ⚠️ НОВОЕ

**Расположение:** `internal/service/service.go:365-369`

Функция `deserializeShard()` — заглушка, которая игнорирует входные данные и возвращает пустую структуру.

```go
func (s *Service) deserializeShard(data []byte) (*crypto.CharacterShard, error) {
    return &crypto.CharacterShard{}, nil  // Всегда пусто!
}
```

**Бизнес-влияние:** Даже если бы шифрование работало корректно, данные невозможно восстановить. Все операции разблокировки возвращают пустые/повреждённые данные.

**Критичность:** КАТАСТРОФИЧЕСКАЯ

---

### 4. Получение Ownership Proof не функционирует ⚠️ НОВОЕ

**Расположение:** `internal/service/service.go:381-389`

Функция `getOwnershipProof()` читает данные из хранилища, но игнорирует их, возвращая пустую структуру.

```go
func (s *Service) getOwnershipProof(assetID string) (*crypto.OwnershipProof, error) {
    _, err := s.storage.UTXOStore().Get([]byte(key))  // Данные игнорируются!
    if err != nil {
        return nil, err
    }
    return &crypto.OwnershipProof{}, nil  // Пустой proof
}
```

**Бизнес-влияние:** ZKP верификация владения бессмысленна. Система не может проверить, кому принадлежат активы.

**Критичность:** КРИТИЧЕСКАЯ

---

### 5. Цифровые подписи фактически не проверяются

**Расположение:** `internal/lockscript/vm.go:306-309`

Система верификации подписей — заглушка, принимающая любой непустой ввод как валидный.

```go
func (vm *VirtualMachine) verifySignature(pubKey, message, signature string) bool {
    return len(pubKey) > 0 && len(message) > 0 && len(signature) > 0
}
```

**Бизнес-влияние:** Полный обход верификации владения. Активы может украсть любой, передав любую строку как "подпись".

**Критичность:** КАТАСТРОФИЧЕСКАЯ

---

### 6. ZKP используют XOR вместо криптографического хеша

**Расположение:** `internal/crypto/zkp.go:353-384`

Функции commitment используют XOR операции вместо криптографических хешей. XOR обратим и не обеспечивает безопасности.

```go
for i := range ownerSecret {
    h[i%32] ^= ownerSecret[i]  // XOR — это НЕ хеш!
}
```

**Бизнес-влияние:**
- ZKP доказательства можно тривиально подделать
- Секреты владельцев можно восстановить из commitment
- Гарантии приватности не существуют

**Критичность:** КРИТИЧЕСКАЯ

---

### 7. Проверки целостности данных неэффективны

**Расположение:** `internal/crypto/encrypt.go:287-293`

Система использует XOR-контрольные суммы вместо криптографических MAC. Коллизии создаются тривиально.

**Бизнес-влияние:** Зашифрованные активы можно повредить или подменить без обнаружения.

**Критичность:** КРИТИЧЕСКАЯ

---

### 8. Salt шифрования не сохраняется

**Расположение:** `internal/crypto/hkdf.go:49-53`

Salt, необходимый для деривации ключей, генерируется случайно, но никогда не сохраняется. Даже если бы мастер-ключ сохранялся, данные всё равно были бы невосстановимы.

**Бизнес-влияние:** Усугубляет проблему потери ключей. Двойной механизм отказа для восстановления активов.

**Критичность:** КРИТИЧЕСКАЯ

---

### 9. Сетевое соединение не зашифровано по умолчанию

**Расположение:** `internal/service/grpc_server.go:54-61`

TLS реализован, но отключен по умолчанию. Система может работать без шифрования, если не сконфигурирована явно.

```go
if tlsEnabled {  // Только если явно включено
    creds, err := credentials.NewServerTLSFromFile(...)
}
```

**Бизнес-влияние:** При развёртывании без правильной конфигурации все данные передаются открытым текстом. MITM-атаки могут перехватить коммуникации.

**Критичность:** ВЫСОКАЯ (зависит от конфигурации)

---

## Уязвимости высокого риска

### 10. Возможны timing-атаки

**Расположение:** `internal/crypto/encrypt.go:296-307`

Сравнения безопасности используют early-return логику, утекающую информацию через время ответа.

```go
for i := range calculated {
    if calculated[i] != checksum[i] {
        return false  // Early return утекает тайминг
    }
}
```

**Исправление:** Использовать `crypto/subtle.ConstantTimeCompare()`

---

### 11. Rate limiting не применяется к core service

**Расположение:** `internal/service/service.go`

Хотя middleware для rate limiting существует (`internal/middleware/ratelimit.go`), он не применяется автоматически к core service. Развёртывание без middleware оставляет систему уязвимой.

**Исправление:** Интегрировать rate limiting в service layer или обязать использование middleware.

---

### 12. Память может быть исчерпана

**Расположение:** `internal/crypto/memory.go:64-73`

Пул безопасной памяти создаёт неограниченное количество новых буферов при исчерпании, позволяя DoS-атаки.

```go
default:
    // Pool исчерпан, создаём новый буфер — БЕЗ ЛИМИТА!
    buf := &SecureBuffer{data: make([]byte, p.bufSize)}
```

**Исправление:** Добавить максимальный лимит буферов.

---

### 13. Криптографические ключи утекают в памяти

**Расположение:** `internal/crypto/hkdf.go:72-73`

Производные ключи возвращаются в sync.Pool без очистки, оставляя чувствительный материал доступным в памяти.

```go
derivedKey := h.derivedKeysPool.Get().([]byte)
defer h.derivedKeysPool.Put(derivedKey)  // Не очищается!
```

**Исправление:** Вызывать `clearBytes(derivedKey)` перед возвратом в пул.

---

### 14. Переполнение чисел может вызвать коллизию ключей

**Расположение:** `internal/crypto/encrypt.go:120`

Переполнение integer при деривации ключей может привести к использованию одного ключа для разных активов.

```go
shardKey, err := e.hkdfManager.DeriveKeyForShard(shardID + index)  // uint32 overflow
```

**Исправление:** Использовать uint64 или safe math операции.

---

### 15. Предсказуемые случайные числа в контексте безопасности

**Расположение:** `internal/verification/selector.go`, `internal/verification/retry.go`

Несколько файлов используют `math/rand` вместо `crypto/rand` для операций, критичных к безопасности.

**Исправление:** Заменить все использования `math/rand` на `crypto/rand`.

---

## Системные проблемы

### 16. Отсутствует корпоративное управление ключами

Нет интеграции с промышленными системами управления ключами (HSM, HashiCorp Vault, AWS KMS). Ключи существуют только в памяти приложения.

---

### 17. Неполный аудит-трейл

События безопасности не логируются полностью. Система аудита не имеет защиты от подделки (hash chain) и может молча терять записи.

---

### 18. Ошибки сборки — циклический импорт ⚠️ ПОДТВЕРЖДЕНО

**Ошибка:**
```
imports github.com/dueldanov/lockbox/v2/internal/service: import cycle not allowed
```

Кодовая база имеет циклические зависимости, предотвращающие успешную компиляцию:
```
service → monitoring → verification → service
```

---

### 19. Отсутствует валидация ввода

Пользовательский ввод не валидируется по размеру, формату или содержанию:
- Нет лимита на размер массива `MultiSigAddresses`
- Нет валидации длины `LockScript`
- Нет санитизации `OwnerAddress`

---

### 20. Слабые параметры Argon2

**Расположение:** `internal/crypto/encrypt.go:29-33`

```go
Argon2Time    = 1          // Слишком мало
Argon2Memory  = 64 * 1024  // 64KB — слишком мало для 2024+
Argon2Threads = 4
```

**Рекомендация:** Time=3, Memory=64MB+

---

## Оценка рисков

| Категория | Количество | Уровень риска |
|-----------|------------|---------------|
| Полная потеря данных | 4 | КАТАСТРОФИЧЕСКИЙ |
| Обход авторизации | 3 | КАТАСТРОФИЧЕСКИЙ |
| Целостность данных | 2 | КРИТИЧЕСКИЙ |
| Раскрытие информации | 3 | ВЫСОКИЙ |
| Отказ в обслуживании | 3 | ВЫСОКИЙ |
| Качество кода | 4 | СРЕДНИЙ |
| Архитектура | 8 | СРЕДНИЙ |

---

## Сценарии атак

### Сценарий 1: Полная кража активов
```
1. Атакующий вызывает UnlockAsset с любым assetID
2. verifySignature() принимает любую строку как валидную подпись
3. Атакующий получает разблокированный актив
4. Требуемое время: секунды
```

### Сценарий 2: Невозможность восстановления данных
```
1. Пользователь блокирует ценные активы
2. Система перезапускается (обновление, сбой, масштабирование)
3. Генерируется новый мастер-ключ
4. Все предыдущие активы навсегда недоступны
5. Восстановление невозможно
```

### Сценарий 3: Подделка ZKP
```
1. Атакующий наблюдает публичный commitment
2. XOR обратим: secret = commitment ^ known_values
3. Атакующий восстанавливает секрет владельца
4. Атакующий подделывает ownership proof
5. Атакующий забирает активы
```

---

## Дорожная карта исправлений

### Фаза 1: Заставить работать (Критическое)

| Приоритет | Задача | Трудозатраты |
|-----------|--------|--------------|
| 1 | Исправить баг копирования masterKey | 1 час |
| 2 | Реализовать сохранение ключа | 1 день |
| 3 | Реализовать deserializeShard() | 1 день |
| 4 | Реализовать getOwnershipProof() | 4 часа |
| 5 | Реализовать Ed25519 верификацию подписей | 1 день |
| 6 | Заменить XOR на SHA256 в ZKP | 4 часа |
| 7 | Исправить циклический импорт | 2-4 часа |

### Фаза 2: Сделать безопасным (Высокое)

| Приоритет | Задача | Трудозатраты |
|-----------|--------|--------------|
| 8 | Заменить XOR checksum на HMAC | 4 часа |
| 9 | Добавить constant-time сравнения | 2 часа |
| 10 | Сохранять salt вместе с данными | 4 часа |
| 11 | Очищать ключи перед возвратом в пул | 1 час |
| 12 | Заменить math/rand на crypto/rand | 2 часа |

### Фаза 3: Подготовка к продакшену (Среднее)

| Приоритет | Задача | Трудозатраты |
|-----------|--------|--------------|
| 13 | Интегрировать KMS (Vault/AWS) | 1 неделя |
| 14 | Реализовать ротацию ключей | 3 дня |
| 15 | Добавить лимиты пула памяти | 2 часа |
| 16 | Добавить валидацию ввода | 1 день |
| 17 | Включить TLS по умолчанию | 4 часа |
| 18 | Усилить параметры Argon2 | 1 час |
| 19 | Реализовать hash chain для аудита | 2 дня |

### Фаза 4: Валидация

| Задача | Трудозатраты |
|--------|--------------|
| Внутренний security review | 1 неделя |
| Внешний penetration test | 2 недели |
| Документация безопасности | 3 дня |

---

## Заключение

LockBox имеет солидную архитектурную концепцию программируемой блокировки активов. Однако текущая реализация имеет **фундаментальные дефекты, препятствующие базовой функциональности**, помимо проблем безопасности.

### Текущее состояние
```
❌ Шифрование: Ключи всегда нулевые
❌ Персистенция: Данные невозможно прочитать обратно
❌ Авторизация: Любая подпись принимается
❌ ZKP: Доказательства можно подделать
❌ Сборка: Циклический импорт не позволяет компилировать
```

### Рекомендация

**Не разворачивать ни при каких обстоятельствах.** Система не защищает активы — она их теряет.

Оценка времени на исправление: **6-10 недель** с выделенными инженерными ресурсами.

---

**Отчёт подготовлен:** Команда Security Engineering
**Статус ревью:** Финальный v2.0
**Предыдущая версия:** v1.0 (30 ноября 2025)
**Изменения:** Добавлены находки 1, 3, 4, 15, 18. Исправлены находки 9, 11.
